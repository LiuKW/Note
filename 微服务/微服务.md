## 微服务			

### 微服务模块编写

* 建module

* 写pom文件

* 配置application.yml文件

* 编写业务类

* 写启动类，添加响应注解

  ​		

  ​		

**新升级版的SpringCloud组件**

> ![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124235031.png)

​					

​			

​			

### Eureka

> **官方文档：**https://docs.spring.io/spring-cloud-netflix/docs/2.2.5.RELEASE/reference/html/#service-discovery-eureka-clients
>
> ​					
>
> 最开始通过RestTemplate去访问各个服务提供者，但随着各个微服务的提供者太多，所以引入了服务治理的概念。通过一个服务治理端统一管理各个服务。		
>
> ​			
>
> **Eureka**
>
> Eureka就是一个服务注册中心，分为客户端和服务端，用于管理各种服务。各个服务（如：前台服务，订单下单服务，付款服务等）会注册到Eureka注册中心。服务之间可以通过Eureka调用对方，例如：之前是通过 RestTemplate 去向服务提供者发送 http 请求的方式访问调用服务。但是这种方式是需要将请求地址写死的，这样做不太好，起码的负载均衡就实现不了了。所以可以把同样的服务去一样的名字注册到服务中心，restTemplate直接访问服务的名字，就可以做到访问url地址。
>
> ​						
>
> **Eureka服务端**
>
> * 引入依赖
>
>   ```xml
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
>   </dependency>
>   ```
>
> * 编写配置
>
>   ```yaml
>   server:
>     port: 7001
>   
>   # 服务端的配置
>   eureka:
>     instance:
>   	hostname: eureka7001   			#eureka服务端的实例名称
>     client:
>       register-with-eureka: false  # 是否把自己也注册到注册中心，false表示不注册自己
>       fetch-registry: false        # 是否要同步其他注册中心节点的配置，或者注册中心其他服务的配置
>       service-url:
>         # 设置Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址，其他客户端向这个地址注册自己
>         defaultZone: http://a.com:7001/eureka/
>     server:
>       # 关闭自我保护机制
>       enable-self-preservation: false
>       # 心跳连接间隔时间，改成2s，默认是90s
>       eviction-interval-timer-in-ms: 0
>   
>   spring:
>     application:
>       name: eureka-server-7001
>   ```
>
> * 写启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableEurekaServer
>   public class EurekaServer7001Application {
>       public static void main(String[] args) {
>           SpringApplication.run(EurekaServer7001Application.class, args);
>       }
>   }
>   ```
>
>   ​				
>
> **Eureka客户端**
>
> * 引入依赖
>
>   ```xml
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
>   </dependency>
>   ```
>
> * 编写配置
>
>   ```yaml
>   eureka:
>     client:
>       # 表示是否将自己注册进EurekaServer默认为true
>       register-with-eureka: true
>       
>       # 是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负责均衡
>       fetchRegistry: true
>       
>       service-url:
>         # defaultZone: http://localhost:7001/eureka  # 单机版
>         defaultZone: http://a.com:7001/eureka,http://a.com:7002/eureka  # 集群版
>     instance:
>       instance-id: payment8001   # 集群中每个节点的名称
>       prefer-ip-address: true    # 访问路径可以显示IP地址
>       
>   # 开集群的话就把，register-with-eureka 和 fetch-registry 设置为true
>   ```
>
>   ​		
>
> * 写启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableEurekaClient
>   // @EnableDiscoveryClient
>   public class PaymentMain8001 {
>       public static void main(String[] args) {
>           SpringApplication.run(PaymentMain8001.class, args);
>       }
>   }
>   ```
>
>   ​				
>
> **@EnableEurekaClient 和 @EnableDiscoveryClient**
>
> * 让注册中心能够发现，扫描到该服务。
>
> * `@`EnableEurekaClient只有Eureka可以用；@EnableDiscoveryClient 是通用的，可以用于其他注册中心
>
>   ​					
>
> **Eureka集群**
>
> Eureka集群其实就是多个Eureka两两指向，每个Eureka都必须知道其他每个Eureka的存在，也就是说Eureka服务节点要互相注册。例如：1号机注册2号机，2号机注册1号机
>

​				

​			

​			

### Ribbon

> **官方文档：**https://docs.spring.io/spring-cloud-netflix/docs/2.2.5.RELEASE/reference/html/#spring-cloud-ribbon
>
> ​		
>
> **Ribbon**
>
> Ribbon是客户端负责均衡的工具，主要是提供客户端的软件负载均衡算法和服务调用。Ribbon组件提供一系列完善的配置项，如连接超时，重试等。简单配置之后，Ribbon会自动根据某种规则（如轮询，随机连接等）去连接机器。也可以自定义负责均衡算法。
>
> ​		
>
> **Ribbon本地负载均衡客户端 和 Nginx服务端负载均衡区别**
>
> * Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡实现的
>
> * Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术
>
>   ​		
>
> **替换默认负载均衡算法**
>
> Ribbon默认是使用轮询算法做负载均衡
>
> * 创建不同的包路径，官方要求替换负载均衡算法的类需要放在@ComponentScan扫描不到的包下。如果放在@ComponentScan扫描的包下注册中心的所有Ribbon客户端都可以共享。如果只想单独一的节点的Ribbon使用这个算法则需要额外建立一个包。
>
>   ```java
>   // package com.kingwait   启动类的路径
>   package com.kingwaitconfig;
>   
>   @Configuration
>   public class MySelfRule {
>       @Bean
>       public IRule myRule() {
>           return new RandomRule();
>       }
>   }
>   ```
>
> * 启动类还要加一个注解 @RibbonClient 指定负载均衡的类
>
>   ```java
>   @SpringBootApplication
>   @EnableDiscoveryClient
>   @RibbonClient(name = "PROVIDER", configuration = MySelfRule.class)
>   public class Consumer80Application {
>       public static void main(String[] args) {
>           SpringApplication.run(Consumer80Application.class, args);
>       }
>   
>       @LoadBalanced
>       @Bean
>       public RestTemplate restTemplate() {
>           return new RestTemplate();
>       }
>   }
>   ```
>
>   ​	
>
> **自定义负载均衡算法**
>
> 轮询负载均衡算法原理：rest接口请求次数 % 服务器集群总数量 = 实际调用服务器位置的下标
>
> * 取消掉RestTemplate上的 @LoadBalanced 注解，防止干扰
>
> * 自定义LoadBalance
>
>   ```java
>   @Component
>   public class MyLB {
>       private AtomicInteger atomicInteger = new AtomicInteger(0);
>       
>       public final int getAndIncrement() {
>           int cur;
>           int next;
>           do {
>               cur = this.atomicInteger.get();
>               next = cur > Integer.MAX_VALUE ? 0 : cur + 1;
>           }while(!this.atomicInteger.compareAndSet(cur, next));
>           System.out.println("---------------------" + next);
>           return next;
>       }
>   
>       public ServiceInstance instances(List<ServiceInstance> serviceInstanceList) {
>           int idx = getAndIncrement() % serviceInstanceList.size();
>           return serviceInstanceList.get(idx);
>       }
>   }
>   ```
>
> * 使用
>
>   ```java
>   @RestController
>   @RequestMapping("/rest")
>   public class RestTemplateController {
>       @Autowired
>       private RestTemplate restTemplate;
>   
>       @Autowired
>       private MyLB loadBalancer;
>   
>       @Autowired
>       private DiscoveryClient discoveryClient;
>   
>       @GetMapping("/lb")
>       public String getPaymentLB() {
>           List<ServiceInstance> instances = discoveryClient.getInstances("PROVIDER");
>           if(instances == null || instances.size() <= 0)
>               return null;
>   
>           ServiceInstance serviceInstance = loadBalancer.instances(instances);
>           URI uri = serviceInstance.getUri();
>           return restTemplate.getForObject(uri + "/provider/port", String.class);
>       }
>   
>   }
>   ```
>
>   ​		
>
> **小结：**使用Ribbon做负载均衡实际上就是，Ribbon + RestTemplate 的rest调用

​			

​		

​		

### OpenFeign

> **官方文档：**https://docs.spring.io/spring-cloud-openfeign/docs/2.2.5.RELEASE/reference/html/
>
> ​			
>
> **OpenFeign**
>
> * OpenFeign也是用于**负载均衡**，它是一个声明式WebService客户端。使用OpenFeign能让WebService客户端更加简单。
>
> * OpenFeign是SpringCloud在Feign进行了封装，使其支持了 SpringMVC 标准注解和 HttpMessageConverters。如SpringMVC中的@RequestMapping等，OpenFeign的@FeginClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方法产生实现类，实现类中做负载均衡并调用其他服务。
>
> *  `使用方式`：定义一个服务接口，在接口添加注解
>
> ​			
>
> **使用OpenFeign**
>
> * 引入依赖
>
>   ```yaml
>   <dependency>
>   	<groupId>org.springframework.cloud</groupId>
>   	<artifactId>spring-cloud-starter-openfeign</artifactId>
>   </dependency>
>   ```
>
>   ​	
>
> * 编写配置
>
>   ```yaml
>   # 简单编写一下Eureka配置即可，不需要注册自己，能够从注册中心获取其他服务即可
>   server:
>     port: 81
>   
>   eureka:
>     client:
>       register-with-eureka: false
>       service-url:
>         defaultZone: http://a.com:7001/eureka
>   ```
>
>   ​		
>
> * 编写业务类
>
>   ```java
>   @Component  // 貌似不加也可以
>   @FeignClient(value = "PROVIDER")  // 声明调用的是哪个服务  
>   public interface ProviderFeignService {
>       @GetMapping("/provider/all")
>       Collection<User> findAll();
>   
>       @GetMapping("/provider/{id}")
>       User findById(@PathVariable("id") Long id);
>   
>       @PostMapping("/provider/add")
>       void addUser(@RequestBody User user);
>   
>       @DeleteMapping("/provider/{id}")
>       void deleteById(@PathVariable("id") Long id);
>   
>       @GetMapping("/provider/port")
>       String port();
>   }
>   
>   
>   // ---------controller中直接用即可--------- //
>   
>   
>   @RestController
>   @RequestMapping("/feign")
>   public class FeignController {
>       @Autowired
>       private ProviderFeignService providerFeignService;
>   
>       @GetMapping("/all")
>       public Collection<User> findAll() {
>           return providerFeignService.findAll();
>       }
>   ```
>
>   ​	
>
> * 编写启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableFeignClients
>   public class ConsumerFeign81Application {
>       public static void main(String[] args) {
>           new SpringApplicationBuilder(ConsumerFeign81Application.class).run(args);
>       }
>   }
>   ```
>
>   ​		
>
> **超时控制**
>
> OpenFeign默认请求超过 1 秒钟，就会报超时错误，通过配置文件延长时间
>
> ```yaml
> # 接上配置文件，最左
> # 设置Feign客户端超时时间（OpenFeign底层是由ribbon支持的）
> ribbon:
>   # 建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间，以秒为单位
>   ReadTimeout: 5000
>   # 建立连接后从服务器读取到可用资源所用的时间
>   ConnectTimeout: 5000
> ```
>
> ​		
>
> **OpenFeign日志打印**
>
> * Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http请求的细节，对 Feign 接口的调用情况进行监控和输出。如果业务中调用非常频繁，需要知道每一步的情况，可以打开OpenFeign的日志功能
>
> * 日志显示详细程度级别
>
>   * `NONE`：默认，不显示任何日志
>
>   * `BASIC`：仅记录请求方法、URL、响应状态码及执行时间
>
>   * `HEADERS`：除了BASIC中定义的信息外，还有请求头和响应头的信息
>
>   * `FULL`：除了HEADERS中定义的信息外，还有请求和响应的正文及元数据
>
>     ​	
>
> * 使用方式
>
>   * 编写配置类
>
>     ```java
>     @Configuration
>     public class FeignConfig {
>         @Bean
>         Logger.Level feignLoggerLevel() {
>             return Logger.Level.FULL;
>         }
>     }
>     ```
>
>   * 编写配置文件
>
>     ```yaml
>     # 接上配置，层级是最左
>     logging:
>       level:
>         # feign日志以什么级别监控哪个接口
>         com.kingwait.service.ProviderFeignService: debug
>     ```
>
>     

​			

​			

​			

### Hystrix

> **官方文档：**https://docs.spring.io/spring-cloud-netflix/docs/2.2.5.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix
>
> ​			
>
> **Hystrix**
>
> * Hystrix断路器，是一个用于处理分布式系统延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。
>
> * 通过断路器的故障监控，遇到异常时，向调用方返回一个符合一起的、可处理的备选响应，而不是长时间的等待或抛出调用方无法处理的异常。这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免故障在分布式系统中的蔓延，乃至雪崩。
>
> * Hystrix可以用作**服务降级，服务熔断，实时监控，**限流，隔离等。
>
>   ​			
>
> **Hystrix重要概念**
>
> * 服务降级
>
>   * 在高并发的情况下，防止用户一直等待，使用服务降级方式进行处理。当服务不可用的时候(正在等待的时候、网络延迟、响应时间过长)，客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理。
>
>   * 降级的场景：
>
>     1、程序运行异常；2、超时；3、服务熔断触发服务降级；4、线程池信号量打满
>
>     
>
> * 服务熔断
>
>   * 在高并发的情况下，如果达到一定的极限，如果流量超出了设置的阈值，然后拒绝访问，保护当前服务。当服务器达到最大的承受能力的之后，直接拒绝访问服务，然后调用降级方法，返回友好提示
>
>   * 服务熔断分两步：**降级**进而熔断，**恢复**调用链路
>
>     
>
> * 服务限流
>
>   * 如秒杀等高并发操作，防止同时进来，排队慢慢处理。
>
>     ​					
>
> **Hystrix服务降级**
>
> 首先要明白一点，Hystrix的服务降级即可以放在服务端，也可以放在客户端（提供者 or 消费者）。服务降级可以处理异常和超时
>
> ​						
>
> **服务提供方出错后降级的方式**
>
> 简单的说就是在服务方法上面加一个@HystrixCommand的注解配置一下（可以在service层，也可以在controller层），指定发生异常或超时后的处理方法。
>
> * 引入依赖
>
>   ```xml
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
>   </dependency>
>   ```
>
> * 编写配置
>
>   ```yaml
>   // 和其他eureka client一样，只需要配置注册到eureka就行了
>   server:
>     port: 82
>   
>   eureka:
>     client:
>       register-with-eureka: true
>       fetch-registry: true
>       service-url:
>         defaultZone: http://a.com:7001/eureka/
>   
>   spring:
>     application:
>       name: provider-hystrix-82
>   ```
>
> * 编写业务类
>
>   ```java
>   @Service
>   public class HystrixService {
>       /**
>        * 正常的方法，肯定ok
>        */
>       @HystrixCommand(fallbackMethod = "serviceInfoTimeOutHandler", commandProperties = {
>               @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", 
>                                value = "1000")
>       })
>       public String serviceInfo() {
>           return Thread.currentThread().getName();
>       }
>   
>       public String serviceInfoTimeOutHandler() {
>           return "线程池：" + Thread.currentThread().getName() + 
>               " serviceInfo1TimeOutHandler，" + "业务繁忙，请稍后重试";
>       }
>   
>       /**
>        * 异常的方法，模拟出错
>        */
>       @HystrixCommand(fallbackMethod = "serviceInfo1TimeOutHandler", commandProperties = {
>               @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", 
>                                value = "2000")
>       })
>       public String serviceInfo1() {
>           // int age = 10 / 0;
>           try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
>           return Thread.currentThread().getName() + "-------------延时 3 秒钟";
>       }
>   
>       public String serviceInfo1TimeOutHandler() {
>           return "线程池：" + Thread.currentThread().getName() + 
>               " serviceInfo1TimeOutHandler，" + "业务繁忙，请稍后重试";
>       }
>   }
>   ```
>
> * 启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableDiscoveryClient
>   @EnableCircuitBreaker   // 开启降级注解
>   public class ProviderHystrix82 {
>       public static void main(String[] args) {
>           SpringApplication.run(ProviderHystrix82.class, args);
>       }
>   }
>   ```
>
>   ​		
>
> **客户端（消费方）的服务降级**
>
> 上面的是服务端出错的解决方案，但是在实际业务中，不仅仅是服务端会出错，可能客户端也会出错。所以客户端也需要实现降级
>
> 消费端的服务调用一般是用feign，所以要结合feign使用
>
> * 引入依赖
>
>   ```xml
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
>   </dependency>
>   
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-openfeign</artifactId>
>   </dependency>
>   ```
>
> * 编写配置
>
>   ```yaml
>   server:
>     port: 80
>   
>   spring:
>     application:
>       name: consumer-hystrix-80
>   
>   eureka:
>     client:
>       register-with-eureka: true
>       service-url:
>         defaultZone: http://a.com:7001/eureka/
>       
>   feign:
>     hystrix:
>       enabled: true    # 开启feign中的hystrix的配置
>   ```
>
> * 编写业务类
>
>   ```java
>   @RestController
>   @RequestMapping("/hystrix-consumer")
>   public class HystrixController {
>       @Autowired
>       private HyStrixService hyStrixService;
>   
>       @HystrixCommand(fallbackMethod = "controllerTimeOutHandler", commandProperties = {
>               @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "100")
>       })
>       @GetMapping("/formal")
>       public String formal() {
>           return hyStrixService.formal();
>       }
>   
>       public String controllerTimeOutHandler() {
>           return "我是80端口的消费端，82端口的服务端的业务繁忙，请稍后重试";
>       }
>   
>       @GetMapping("/err")
>       public String err() {
>           return hyStrixService.err();
>       }
>   }
>   ```
>
> * 编写启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableDiscoveryClient
>   @EnableFeignClients
>   @EnableHystrix
>   public class ConsumerHyStrix80 {
>       public static void main(String[] args) {
>           new SpringApplicationBuilder(ConsumerHyStrix80.class).run(args);
>       }
>   }
>   ```
>
>   ​	
>
> **使用@HystrixCommand的缺陷**
>
> * 处理方法不够优雅，每个需要降级的方法都需要指定一个降级的方法处理异常或超时，导致整个业务逻辑代码十分冗杂无章，不够优雅。而且大部分降级使用的方法处理方式都是一样的，例如返回系统繁忙等字样。只有少数方法的降级是需要额外处理的。
>
> * 所以在实际开发中我们并不常用上述方式处理，而是使用**@DefaultProperties**统一处理。
>
>   ​	
>
> **@DefaultProperties**
>
> * 具体的依赖、配置文件、启动类配置和上面的一样。在业务处理方法中有所不同。
>
>   ```java
>   @RestController
>   @RequestMapping("/hystrix-consumer")
>   @DefaultProperties(defaultFallback = "controllerGlobalTimeOutHandler")
>   public class HystrixController {
>       @Autowired
>       private HyStrixService hyStrixService;
>   
>       @HystrixCommand
>       @GetMapping("/formal")
>       public String formal() {
>           int a = 10 / 0;
>           return hyStrixService.formal();
>       }
>   
>       @GetMapping("/err")
>       public String err() {
>           return hyStrixService.err();
>       }
>   
>       public String controllerGlobalTimeOutHandler() {
>           return "我是80端口的消费端，这是全局的异常降级处理方法，请稍后重试";
>       }
>   
>   }
>   ```
>
>   在业务类上标注@DefaultProperties(defaultFallback = "controllerGlobalTimeOutHandler")注解，指定降级方法，在需要降级的方法上面标注@HystrixCommand，一定要加。如果方法上没有标注@HystrixCommand，则不会处理降级。
>
>   ​			
>
> **但是通过@DefaultProperties的方式做降级好像还是不够优雅，业务类还是参杂着降级的代码**
>
> * 可以发现只要是用到feign调用的消费端，都需要定义一个接口，接口上都有个@FeignClient的注解。只需要为feign客户端定义的接口添加一个服务降级处理的实现类即可实现业务代码与容错降级的代码解耦
>
> * 同样的，具体的依赖、配置文件、启动类配置和上面的一样。
>
>   ```yaml
>   server:
>     port: 80
>   
>   spring:
>     application:
>       name: consumer-hystrix-80
>   
>   eureka:
>     client:
>       register-with-eureka: true
>       service-url:
>         defaultZone: http://a.com:7001/eureka/
>       
>   feign:
>     hystrix:
>       enabled: true    # 开启feign中的hystrix的配置
>   ```
>
> * Feign调用接口
>
>   ```java
>   // 注意@FeignClient注解的fallback
>   @Component
>   @FeignClient(value = "PROVIDER-HYSTRIX-82", fallback = HystrixServiceImpl.class)
>   public interface HyStrixService {
>       @GetMapping("/hystrix/formal")
>       String formal();
>   
>       @GetMapping("/hystrix/err")
>       String err();
>   }
>   ```
>
> * Fallback类，即接口的实现类
>
>   ```java
>   @Component
>   public class HystrixServiceImpl implements HyStrixService {
>       @Override
>       public String formal() {
>           return "这是使用继承调用接口实现的最解耦的方式处理降级";
>       }
>   
>       @Override
>       public String err() {
>           return "这是使用继承调用接口实现的最解耦的方式处理降级";
>       }
>   }
>   ```
>
> * controller和service层的代码无需变更
>
> 
>
> 





​			

### Gateway

> **官方文档：**https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/
>
> ​					
>
> **Gateway**
>
> 网关，微服务项目通常有很多个服务，每个服务都是在不同端口、不同主机上，它们的地址各不相同。客户端不可能每次都访问不同的地址调用服务。所以就有了网关的诞生，通过网关帮我们路由到正确的服务上。网关可以做限流，反向代理、校验鉴权、日志监控等功能。
>
> ​				
>
> **Spring-Cloud-Gateway**
>
> * 引入依赖
>
>   ```xml
>   <dependency>
>       <groupId>org.springframework.cloud</groupId>
>       <artifactId>spring-cloud-starter-gateway</artifactId>
>   </dependency>
>   ```
>
>   ​			
>
> * 编写路由配置
>
>   ```yaml
>   spring:
>     application:
>       name: gateway-88
>     cloud:
>       gateway:
>         routes:
>           - id: provider_1   # 路由id没有特殊含义，区分不同的路由，要求唯一，建议配合服务名
>             uri: http://a.com:8001  # 匹配后提供服务的路由地址，路由到什么地址
>             predicates:
>               - Path=/provider/**   # 断言，符合这个规则的地址就会被路由
>   
>           - id: provider_2
>             uri: http://a.com:8002
>             predicates:
>               - Path=/provider/**
>   
>   
>   #---------------------------以上是非负载均衡的写法-----------------------------------------
>   
>   
>   spring:
>     application:
>       name: gateway-88
>     cloud:
>       gateway:
>         discovery:
>           locator: true   # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
>         routes:
>           - id: provider_1
>             uri: lb://PROVIDER  # 服务的名称， lb是负载均衡的意思
>             predicates:
>               - Path=/provider/**
>   
>           - id: provider_2
>             uri: lb://PROVIDER
>             predicates:
>               - Path=/provider/**
>   ```
>
>   上面是用配置文件的方式配置，也可以用代码的方式配置路由
>
>   ```java
>   // 非负责均衡的写法
>   @Configuration
>   public class GatewayConfig {
>       @Bean
>       public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {
>           RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
>   
>           routes.route("provider_1",
>                   r -> r.path("/provider/**")
>                           .uri("http://a.com:8001"));
>           return routes.build();
>       }
>   }
>   
>   // 负责均衡的写法
>   @Configuration
>   public class GatewayConfig {
>       @Bean
>       public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {
>           RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
>   
>           routes.route("provider",
>                   r -> r.path("/provider/**")
>                           .uri("lb://PROVIDER"));
>           return routes.build();
>       }
>   }
>   ```
>
>   ​					
>
> * 写启动类
>
>   ```java
>   @SpringBootApplication
>   @EnableDiscoveryClient
>   public class Gateway88Application {
>       public static void main(String[] args) {
>           SpringApplication.run(Gateway88Application.class, args);
>       }
>   }
>   ```
>
>   ​							
>
> **配置断言、过滤器等参考官方文档**
>
> ​					
>
> **自定义全局过滤器**
>
> * 实现 GlobalFilter，Ordered接口，重写两个方法即可。
>
> * 全局过滤器通常用于做权限校验、全局日志记录等
>
> ```java
> @Component
> @Slf4j
> public class MyLogGatewayFilter implements GlobalFilter, Ordered {
> 
>     @Override
>     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
>         log.info("ffffffffffffffffffffffff" + new Date());
>         String uname = exchange.getRequest().getQueryParams().getFirst("uname");
>         if(uname == null) {
>             log.info("用户名为空，非法用户");
>             exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
>             return exchange.getResponse().setComplete();
>         }
> 
>         // 放行到过滤链中的下一个过滤器
>         return chain.filter(exchange);
>     }
> 
>     // 过滤器优先级，数字越低优先级越高，生效的位置就越后
>     @Override
>     public int getOrder() {
>         return 0;
>     }
> }
> ```
>
> ​						
>
> **注意：**网关不能引入web依赖

​			

  
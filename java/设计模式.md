## 设计模式

### Singleton（单例模式）

> 单例模式用于保证对象全局唯一
>
> 单例模式有很多种写法
>
> **饿汉式**
>
> ```java
> public class Singleton1 {
>     private Singleton1(){}
>     private static Singleton1 instance = new Singleton1();
>     public static Singleton1 getInstance() { return instance; }
> 
>     public static void main(String[] args) {
>         Singleton1 singleton1_1 = Singleton1.getInstance();
>         Singleton1 singleton1_2 = Singleton1.getInstance();
>         System.out.println(singleton1_1==singleton1_2);
>     }
> }
> ```
>
> ​						
>
> **懒加载（DCL）**
>
> ```java
> public class Singleton5 {
>     private static volatile Singleton5 instance;
>     private Singleton5(){}
>     private static Singleton5 getInstance()
>     {
>         if(instance == null) {
>             synchronized (Singleton5.class) {
>                 if(instance == null) {
>                     instance = new Singleton5();
>                 }
>             }
>         }
>         return instance;
>     }
> }
> ```
>
> 还有静态内部类、枚举的写法，不过我觉得这两种最直观吧。总感觉枚举的写法怪怪的

​				

​			

### Strategy（策略模式）

> 

​				

​			

### Observer（观察者模式）

> 

​			
​			

### Adapter（适配器模式）

> 适配器，字面意思理解就行了。 例如：变压器等。
>
> 一个类不能直接访问另一个类的时候，中间加一层进行转换，中间这一层就叫做Adapter。
>
> 在Java中，最常见的Adapter就是InputStreamReader（Stream和Reader的转换流）。
>
> ​				
>
> **误区**：
>
> 我们在Java代码中，常看到的Adapter，反而不是Adapter模式。例如WindowAdapter，它没用到设计模式，只是一种编程技巧
>
> 

​				

​						

### Decorator（装饰器模式）

> 顾名思义，装饰用的。就是原来有个东西，现在在其上面加一个装饰。
>
> 例如：Notepad++加一个滚动条、边框；IDEA改个主题啥的；王者荣耀英雄皮肤；都是装饰器模式。
>
> ​				
>
> 
>
> 

​					

​					

### Command（命令模式）

> Command模式又称Action（动作） 或 Transaction（事务）。通常用于实现undo的功能
>
> ​			
>
> **直接上代码，更加直观**
>
> > **Command**			
> >
> > * Command类就是一系列命令的需要完成的功能。例如我们自己实现一个编辑器，命令执行后需要撤销，重做等功能，就是定义在这个类里面
> >
> >   ```java
> >   // 通常这个Comamnd类会封装一系列命令
> >   public abstract class Command {
> >       public abstract void doit();  // 工作命令
> >       public abstract void undo();  // 撤销
> >       // 还可以有其他命令，重做功能等...
> >   }
> >   ```
> >
> >   
> >
> > **Content**
> >
> > * Content就是实际被撤销，重做的东西。在编辑器里面就是内容了，画板软件的话就是笔画咯
> >
> >   ```java
> >   public class Content {
> >       String msg = "hello everybody";
> >       // 省略构造方法
> >   }
> >   ```
> >
> >   ​		
> >
> > **命令的实现类InsertCommand、CopyCommand、DeleteCommand等**
> >
> > **InsertCommand**
> >
> > ```java
> > public class InsertCommand extends Command {
> >     Content c;
> >     String strToInsert = "http://kingwait.com";
> >     public InsertCommand(Content c) { this.c = c; }
> > 
> >     @Override
> >     public void doit() { c.msg = c.msg + strToInsert; }
> > 
> >     @Override
> >     public void undo() { c.msg = c.msg.substring(0, c.msg.length() - strToInsert.length()); }
> > }		
> > ```
> >
> > **CopyCommand**
> >
> > ```java
> > public class CopyCommand extends Command {
> >     Content c;
> > 
> >     public CopyCommand(Content c) { this.c = c; }
> > 
> >     @Override
> >     public void doit() { c.msg = c.msg + c.msg; }
> > 
> >     @Override
> >     public void undo() { c.msg = c.msg.substring(0, c.msg.length() / 2); }
> > }
> > ```
> >
> > **DeleteCommand**
> >
> > ```java
> > public class DeleteCommand extends Command {
> >     Content c;
> >     String deleteStr;  // 记录被删除的内容，undo的时候需要用到
> >     public DeleteCommand(Content c) { this.c = c; }
> > 
> >     @Override
> >     public void doit() {
> >         // 模拟删除前五个字符
> >         deleteStr = c.msg.substring(0, 5);
> >         c.msg = c.msg.substring(5, c.msg.length());
> >     }
> > 
> >     @Override
> >     public void undo() { c.msg = deleteStr + c.msg; }
> > }
> > ```
> >
> > ​			
> >
> > **Main**，主类执行
> >
> > ```java
> > public class Main {
> >     public static void main(String[] args) {
> >         Content c = new Content();
> > 
> >         Command insertCommand = new InsertCommand(c);
> >         insertCommand.doit();
> >         insertCommand.undo();
> > 
> >         Command copyCommand = new CopyCommand(c);
> >         copyCommand.doit();
> >         copyCommand.undo();
> > 
> >         Command deleteCommand = new DeleteCommand(c);
> >         deleteCommand.doit();
> >         deleteCommand.undo();
> > 
> >         System.out.println(c.msg);
> >     }
> > } // 注销部分代码可以看到效果
> > ```
>
> ​					
>
> **可以结合责任链模式实现批量撤销功能**


## 垃圾回收

在Java中我们不需要手动回收垃圾，因为垃圾回收的工作已经交由虚拟机完成了。作为Java程序员，即使我们不需要手动释放内存，但是我们依然需要了解垃圾回收器的工作流程，才能写出更高性能的代码。



### 垃圾回收发生在哪里

从总体的JVM内存布局上来看，垃圾回收主要发生在**堆**和**方法区**。大部分的对象都存储在堆内存中，所有通过new创建的对象都分配在堆内存中。而很多对象的生命周期都很短，所以堆中存在着很多已经没用的对象，堆就是垃圾回收器的常客。





### 如何判断对象是否可以被回收，什么对象会被回收

* **引用计数法**
  * 在对象中添加一个引用计数，每当有一个地方引用它时，计数值加一；引用失效时，计数值减一；当计数值未零时，该对象就是不可再被使用，即可以回收。
  * 但是这种方法会出现相互循环引用的问题，所以JVM没有采用这种实现方式（hotspot）
* **可达性分析法**
  * 通过一些列 GC Roots 的对象作为起点，从这些节点往下搜索，搜索走过的路径成为引用链，当一个对象没有任何引用链相连是，则说明这个对象不可用，需要被回收。
  * 可以作为 GC Roots 的对象
    * 虚拟机栈中引用的对象（栈帧中的本地变量表）
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI（Native方法）引用的对象

* **什么对象会被回收**
  * 回收废弃常量
  * 回收无用的类





## 垃圾回收算法

- **标记-清除**

  - 标记所有要清除的对象，标记完成后统一回收。缺点：会产生很多内存碎片

- **复制**

  - 将内存等分成两块，每次只用其中一块，当这块内存用完时，将活着的对象复制到另一块内存上
  - 有研究表明，对象的生存率约为98%，基于这种思路，不必将内存等分，可以按照 8 : 1 的比例划分内存

- **标记-整理**

  - 这块内存主要用于回收率交校的内存空间，例如：老年代
  - 标记整理算法的思想和标记清除的思想基本相同，不同的是，清除之后，会移动内存，整理内存空间，不会产生内存碎片

- **分代收集**

  - 根据对象存活周期的不同，将内存划分为几块
  - 一般是把Java堆划分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法
  - 例如：新生代中有大量的对象死去，只有少量存货，就采用复制算法。而老年代存活率较高，就采用 “标记-清除” 或 “标记-整理” 算法





### 垃圾回收器

* 垃圾回收算法是垃圾回收的思想和概念，而垃圾回收器就是不同垃圾回收算法的具体实现

* 常见的垃圾回收器分类

  * **Serial收集器**
  * 新生代收集器。单线程，复制算法，回收垃圾时，只能有Serial一个线程工作

  - **ParNew收集器**
    - 新生代收集器。多线程，复制算法，ParNew可以理解为Serial收集器的多线程版本
    - ParNew收集器在单CPU的环境中不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程计数实现的两个CPU环境中都不能百分百保证超越Serial收集器
  - **Parallel Scavenge收集器**
    - 新生代收集器，多线程，复制算法，与ParNew不同的是，Parallel Scavenge收集器更关注吞吐量。吞吐量就是用于运行用户代码的时间于CPU总消耗时间的比值
  - **Serial Old收集器**
    - Serial Old是Serial收集器的老年代版本，单线程，整理-算法
  - **Parallel Old收集器**
    - Parallel Old是Parallel Scavenge收集器的老年代版本，多线程，标记 - 整理算法
  - **CMS收集器**
    - 工作于老年代，多线程，采用标记-清除算法
    - 运作流程：初始标记、并发标记、重新标记、并发清除
  - **G1（Garbage-First）**
    - 工作与整个内存区域
    - 运作流程：初始标记、并发标记、最终标记、筛选回收





### 什么是FullGC、MinorGC、MajorGC

* **MinorGC**

  *  从年轻代空间（包括     Eden 和 Survivor 区域）回收内存被称为 Minor GC
  * 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了

* **MajorGC**

  * 清理永久代

  * 永久代的回收有两种：常量池的回收、无用类的回收
    * 常量池的回收：只要没有引用就能回收
    * 无用类的回收必须满足三个条件
      * 类的所有实例都已经被回收
      * 加载类的ClassLoader已经被回收
      * 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）

* **FullGC**

  * 清理整个堆空间—包括年轻代和永久代
  * 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC。简单地说就是老年代空间不足就会发生FullGC

  



### 虚拟机会在什么时候回收垃圾

* 
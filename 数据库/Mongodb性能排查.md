### Mongodb性能排查

我们使用mongodb排查性能主要有三个工具，mongodb自带的工具

#### mongostat

mongostat工具，我们mongodb的bin目录可以看到这个目录下面有很多mongodb自带的工具。

![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124232552.png)



例如最熟悉的mongod，mongo，这两个是用于启动mongodb服务器和客户端的。还有其他的一些工具，例如mongodump和mongorestore，这两个是用于备份和恢复数据库的。我们今天要给大家介绍的一个工具是mongostat，这是一个可以查看mongodb当前工作状态的工具。我们执行mongostat -h hostname:port就能够进入mongostat的监测界面。

![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124232615.png)



监测界面如上图，

**insert：**数据库每秒插入次数

**query：**数据库每秒查询次数

**update：**数据库每秒更新次数

**delete：**数据库每秒删除次数

**getmore：**游标执行次数

**command：**数据库每秒命令执行次数，包含添删改查以及其他的命令，例如创建索引

**dirty：**脏数据比例，脏数据指的是存储在数据库内存中，但是还没有刷入磁盘的数据。而这比例一旦超过20%，mongodb就会把所有性能都用来刷盘。默认是60s刷一次盘，而如果脏数据太多 ，mongodb有可能就会阻塞其他操作，竭尽全力把内存中的数据，存储到硬盘。

**used：**数据库当前使用了多少内存，这个内存指的是mongodb服务可以申请到的内存的百分比。通常mongodb会把查询到的数据先放到磁盘里，如果前端有查询请求过来且内存中有相应的数据，直接就可以在内存中拿到数据，而不需要去访问磁盘，可以很大地提高数据库读效率。但是内存不是无限大的，当这个值超过80%的时候，mongodb就会清理内存中的数据，如果这个值更大的话可能就会阻塞其他操作。

**flushes：**显示数据库多久刷一次磁盘，例如mongodb的存储引擎一般是60s刷一次

**vsize：**虚拟内存使用量，虚拟内存就是内存不够，额外使用硬盘占用的内存。

**res：**实际内存使用量，单位都是mb

**qrw：**这个是在高并发场景下，有很多mongodb客户端同时执行读写命令，而一些操作涉及到锁，操作而不能同时，其他的操作就只能阻塞的等待在队列中。qr就是读数据的队列长度，qw就是写数据的队列长度

**arw：**这个和上面类似，也是涉及到高并发场景下的读写，ar就是执行读操作的客户端数量，aw就是执行写操作的客户端数量。

**这些数据指标中最重要的就是dirty和used，我们在数据库排查时关键看这两个指标，就可以知道是什么操作影响了数据库性能，然后就可以有根据的去做性能优化**





#### mongotop

这个工具可以方便我们查看mongodb各个集合的读写压力。每个集合读操作或写操作耗时。

同样的，执行mongotop -h hostname:port

![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124232647.png)

通过这个工具，我们也可以快速地定位出现性能问题的位置。





**查看mongodb执行计划**

mongodb的所有find操作都可以看执行计划。命令db.collection.find().explain(true)

例如：我们查询一个没有索引的字段，EstateName字段没有索引。

![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124232754.png)

我们主要查看红线标注的参数，

如上图：COLLSCAN就是说明这个该操作是全表扫描，如果这个表有一千万条数据，就代表这个操作查询了一千万条数据，这个一个非常不好的操作。我们应该尽量避免全表扫描。

nReturned指的就是该操作返回了多少条数据，图中可以看到只返回了1条数据，全表扫描而只返回了一条数据，这是个非常差的查询操作。可以看到耗时executionTimeMillis: 634ms，将近1s，已经是相当慢的操作了。

totalKeysExamined指查询了多少个索引，上图可知，并没有查询索引。

totalDocsExamined指查询了多少条记录，上图可知，查询了301007条记录，这张表总共就是这么多条记录，就是全表扫描了。

根据这个信息我们就可以针对优化了，如果使用EstateName字段的查询操作特别多，我们就应该考虑在这个字段上面加索引。



例如：我们查询有索引的字段。查询一个AreaId，我已经在AreaId上创建了索引

![](https://kingwait-note.oss-cn-chengdu.aliyuncs.com/20201124232817.png)



可以看到响亮的字眼：IXSCAN索引扫描，这个操作扫描的是索引字段。执行时间才1ms，扫描了437个索引，扫描了437条文档。返回了437条数据，可以看到这是一个非常高效的操作。这是在同一张表下执行的操作相比于上面的例如，速度快了几百倍。



**总结：**

* 在对数据进行性能排查的时候我们要首先定位到性能不好的地方，然后根据实际情况做相应的优化。通过mongodb自带的工具mongostat和mongotop快速定位到相应性能较差、耗时较长的操作。
* 当写操作性能比较差时，我们可以考虑是不是索引数太多了。使用索引对查询有很好的优化，但是也会影响插入数据的性能，因为每次插入操作都要去更新索引字段，这个时候可以考虑删除一些不常用的索引。

* 当读性能比较差时，我们就可以考虑在相应字段上创建索引，索引会影响写入性能，但是如果使用该字段的查询操作非常多时，还是建议把索引加上。如果聚合操作的耗时非常长，可以考虑把聚合要统计的字段单独建立一张表出来存储。
















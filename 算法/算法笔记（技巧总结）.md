### 算法笔记（技巧总结）

****

#### 判断回文串

>判断回文串最简单的方法就是**双指针**，头尾定义两个指针。往中间指。
>
>如果是判断单链表等类似只能单项遍历的数据结构，可以将链表遍历一遍保存到list集合中，然后再用双指针
>
>**双指针判断回文串模板**
>
>```java
>int j = arr.length-1;
>
>// 两种循环方式
>for(int k=0;k<arr.length / 2;k++) 
>    if(arr[k] != arr[j-k])
>        // ...
>
>
>// or
>
>while(i <= j) 
>    if(arr[i++] != arr[j--])
>        // ...
>
>```
>

​						

​						

#### 二分查找

>二分查找是需要一定条件的，查找的数组（或者源）一定要是有序的。
>
>总体的思想就是，定义左右指针，中间值就是左右指针之和的一般，中间值与目标值比较，如果目标值小于中间值，指针怎么移动，大于的情况指针怎么移动
>
>**二分查找模板**
>
>```java
>int binarySearch(int []arr, int target) {
>	int left = 0, right = ...;
>
>    while(...) {
>        int mid = (right + left) / 2;
>        if (nums[mid] == target) {
>            ...
>        } else if (nums[mid] < target) {
>            left = ...
>        } else if (nums[mid] > target) {
>            right = ...
>        }
>    }
>    return ...;
>}
>
>
>// 实例
>public static int findIdx(int arr[], int val) {
>    int l = 0;
>    int r = arr.length - 1;
>    if(val == arr[r]) return r;
>    if(val == arr[l]) return l;
>    if(val > arr[r]) return -1;
>    if(val < arr[l]) return -1;
>    while(l <= r) {
>        int mid = (l + r) / 2;
>        if(arr[mid] == val)
>            return mid;
>        else if(arr[mid] > val)
>            r = mid;
>        else
>            l = mid;
>    }
>    return -1;
>}
>```

​		

​					

#### 寻找二叉树的最近祖先

>**Leetcode68题：**
>
>* 题目中有一个前提，二叉树本身是一颗二叉排序树。所以根节点一定小于它的右子树，根节点一定大于它的左子树。
>* 保证p < q，或者q < p
>* 根据二叉排序树的特点，且前面保证了只要p.val > root.val，那么p 和 q
>
>```java
>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
>    // 先保证 p.val < q.val，方便后续的判断
>    if(p.val > q.val) {
>        TreeNode temp = p;
>        p = q;
>        q = temp;
>    }
>
>    /**
>         * 前提逻辑是TreeNode本身是一颗二叉排序树，
>         * 所以根节点一定小于它的右子树，根节点一定大于它的左子树
>         * 
>         * 上面的if已经保证了，p < q。所以
>         *  只要p小于root，那么p和q都在root节点的右子树。
>         *  只要q小于root，那么p和q都在root节点的左子树。
>         * 如果以上两个条件都不符合，那么就说明p和q分别在root节点的左边和右边
>         */
>
>    while(root != null) {
>        if(p.val > root.val)
>            root = root.right;
>        else if(q.val < root.val)
>            root = root.left;
>        else break;
>    }
>    return root;
>}
>```
>

​				

​					

#### 判断是否是平衡二叉树

> **Leetcode110题：**
>
> * 平衡二叉树的定义是，每个节点的左右两个子树的高度差的绝对值不超过 1 
>
> * 总体思想
>   * 自底向上，遍历到最底层之后，每次返回 + 1高度
>   * 只要有一个的节点不是平衡的，那么这颗树肯定不是平衡二叉树
>   * 依次类推，从底层往上层走，**从最底层的节点往上判断只要有一个节点不是平衡的，那么这颗树肯定不是平衡二叉树**
>
> ```java
> public int helper(TreeNode root) {
>     if(root == null) 
>         return 0;
>     
>     int left = helper(root.left);  // 去到最左边的节点
>     if(left == -1)  
>         return -1;
>     // 如果底层返回-1，那么肯定就不是平衡二叉树，只要有一个返回-1，一直都返回-1
>    
>     int right = helper(root.right);
>     if(right == -1)
>         return -1;
>     // 如果底层返回-1，那么肯定就不是平衡二叉树，只要有一个返回-1，一直都返回-1
>     
>     return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
>     								  // 左右子树高度在1以内，向上层+1
> }
> ```
>




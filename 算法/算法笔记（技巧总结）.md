## 算法笔记（技巧总结）

### 判断回文串

* 判断回文串最简单的方法就是**双指针**，头尾定义两个指针。往中间指。

* 如果是判断单链表等类似只能单项遍历的数据结构，可以将链表遍历一遍保存到list集合中，然后再用双指针

* **双指针判断回文串模板**

  ```java
  int j = arr.length-1;
  
  // 两种循环方式
  for(int k=0;k<arr.length / 2;k++) {
      if(arr[k] != arr[j-k])
          // ...
  }
  
  // 或者
  
  while(i <= j) {
      if(arr[i++] != arr[j--])
          // ...
  }
  ```
  

 



### 二分查找

* 二分查找是需要一定条件的，查找的数组（或者源）一定要是有序的。

* 总体的思想就是，定义左右指针，中间值就是左右指针之和的一般，中间值与目标值比较，如果目标值小于中间值，指针怎么移动，大于的情况指针怎么移动

* **二分查找模板**

  ```java
  int binarySearch(int []arr, int target) {
  	int left = 0, right = ...;
  
      while(...) {
          int mid = (right + left) / 2;
          if (nums[mid] == target) {
              ...
          } else if (nums[mid] < target) {
              left = ...
          } else if (nums[mid] > target) {
              right = ...
          }
      }
      return ...;
  }
  
  
  // 实例
  public static int findIdx(int arr[], int val) {
          int l = 0;
          int r = arr.length - 1;
          if(val == arr[r]) return r;
          if(val == arr[l]) return l;
          if(val > arr[r]) return -1;
          if(val < arr[l]) return -1;
          while(l <= r) {
              int mid = (l + r) / 2;
              if(arr[mid] == val)
                  return mid;
              else if(arr[mid] > val)
                  r = mid;
              else
                  l = mid;
          }
          return -1;
      }
  ```

  





### 寻找二叉树的最近祖先

**Leetcode68题：**

* 题目中有一个前提，二叉树本身是一颗二叉排序树。所以根节点一定小于它的右子树，根节点一定大于它的左子树。
* 保证p < q，或者q < p
* 根据二叉排序树的特点，且前面保证了只要p.val > root.val，那么p 和 q

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 先保证 p.val < q.val，方便后续的判断
        if(p.val > q.val) {
            TreeNode temp = p;
            p = q;
            q = temp;
        }

        /**
         * 前提逻辑是TreeNode本身是一颗二叉排序树，
         * 所以根节点一定小于它的右子树，根节点一定大于它的左子树
         * 
         * 上面的if已经保证了，p < q。所以
         *  只要p小于root，那么p和q都在root节点的右子树。
         *  只要q小于root，那么p和q都在root节点的左子树。
         * 如果以上两个条件都不符合，那么就说明p和q分别在root节点的左边和右边
         */

        while(root != null) {
            if(p.val > root.val)
                root = root.right;
            else if(q.val < root.val)
                root = root.left;
            else break;
        }
        return root;
    }
```







### 判断是否是平衡二叉树

**Leetcode110题：**

* 平衡二叉树的定义是，每个节点的左右两个子树的高度差的绝对值不超过 1 

* 总体思想
  * 自底向上，遍历到最底层之后，每次返回 + 1高度
  * 只要有一个的节点不是平衡的，那么这颗树肯定不是平衡二叉树
  * 依次类推，从底层往上层走，**从最底层的节点往上判断只要有一个节点不是平衡的，那么这颗树肯定不是平衡二叉树**

```java
public int helper(TreeNode root) {
    if(root == null) 
        return 0;
    
    int left = helper(root.left);  // 去到最左边的节点
    if(left == -1)  
        return -1;
    // 如果底层返回-1，那么肯定就不是平衡二叉树，只要有一个返回-1，一直都返回-1
   
    int right = helper(root.right);
    if(right == -1)
        return -1;
    // 如果底层返回-1，那么肯定就不是平衡二叉树，只要有一个返回-1，一直都返回-1
    
    return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    								  // 左右子树高度在1以内，向上层+1
}
```







